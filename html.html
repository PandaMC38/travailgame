<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LogiNode - Dashboard System V13</title>
    <style>
        /* Styles de base - Th√®me sombre "IDE / Dashboard" */
        body {
            margin: 0; padding: 0; background-color: #1a1a20; color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden; user-select: none;
        }

        /* Interface Utilisateur (UI) */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; justify-content: space-between;
            padding: 15px; box-sizing: border-box; z-index: 10;
        }

        .panel-container { display: flex; flex-direction: column; gap: 15px; pointer-events: none; width: 330px; }

        .panel {
            background: rgba(26, 26, 32, 0.95); padding: 15px;
            border-radius: 8px; border: 1px solid #3a3a45; pointer-events: auto;
            box-shadow: 0 8px 25px rgba(0,0,0,0.7); max-height: 95vh; overflow-y: auto;
        }

        .header-flex { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        h1 { margin: 0; font-size: 1.1rem; color: #4db8ff; text-transform: uppercase; letter-spacing: 1px; }
        
        .sys-btn { background: #333; color: #aaa; border: 1px solid #555; border-radius: 4px; padding: 4px 10px; font-size: 0.75rem; font-weight: bold; cursor: pointer; transition: 0.2s;}
        .sys-btn:hover { background: #4db8ff; color: #000; border-color: #fff; }
        .sys-btn.danger:hover { background: #e74c3c; color: #fff; border-color: #fff; }

        /* Dashboard Stats */
        .dashboard-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;
        }
        .stat-box {
            background: rgba(0,0,0,0.4); padding: 8px; border-radius: 6px; border: 1px solid #333;
        }
        .stat-label { font-size: 0.65rem; color: #888; text-transform: uppercase; }
        .stat-value { font-size: 1.1rem; font-weight: bold; color: #ffeb3b; }
        .stat-value.cyan { color: #00d2ff; }
        .stat-value.power-ok { color: #2ecc71; }
        .stat-value.power-low { color: #e74c3c; animation: blink 1s infinite; }
        
        @keyframes blink { 50% { opacity: 0.5; } }

        /* Mission Box */
        .mission-box {
            grid-column: span 2; 
            border-color: #4db8ff; 
            background: rgba(77, 184, 255, 0.05);
            transition: all 0.3s ease;
        }
        
        .toolbar { display: flex; flex-direction: column; gap: 5px; }

        .btn {
            background: #23232b; color: #ddd; border: 1px solid #444; padding: 6px 10px;
            border-radius: 4px; cursor: pointer; transition: all 0.1s;
            text-align: left; font-size: 0.8rem; display: flex; align-items: center; gap: 8px;
        }

        .btn:hover { background: #32323d; border-color: #666; color: #fff; }
        .btn.active { background: #4db8ff; color: #000; border-color: #fff; font-weight: bold; }
        
        .shortcut { background: rgba(0,0,0,0.5); padding: 2px 5px; border-radius: 3px; font-size: 0.65rem; margin-left: auto; color: inherit;}

        #gameCanvas { display: block; }

        /* Faux √©cran de travail (Boss Key) */
        #boss-screen {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #fdfdfd; color: #333; z-index: 9999; font-family: Arial, sans-serif;
            padding: 30px; box-sizing: border-box;
        }
        .fake-table { width: 100%; border-collapse: collapse; margin-top: 20px; font-family: monospace; }
        .fake-table th, .fake-table td { border: 1px solid #ddd; padding: 10px; text-align: left; font-size: 13px; }
        .fake-table th { background: #f4f4f4; color: #555;}

        .tutorial { font-size: 0.7rem; color: #999; margin-top: 15px; line-height: 1.4; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 5px;}
        .tutorial strong { color: #fff; }

        /* Notifications */
        #notification {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(46, 204, 113, 0.9); color: #fff; padding: 8px 20px;
            border-radius: 20px; font-size: 0.9rem; font-weight: bold;
            opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 100;
        }

        /* Modals (Upgrades & Sorter) */
        .modal {
            display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(26, 26, 32, 0.98); border: 2px solid #4db8ff; border-radius: 8px;
            padding: 25px; z-index: 50; width: 450px; box-shadow: 0 0 40px rgba(0,0,0,0.9);
            pointer-events: auto;
        }
        .modal h2 { margin-top: 0; color: #4db8ff; text-align: center; border-bottom: 1px solid #444; padding-bottom: 10px; }
        .close-modal { position: absolute; top: 10px; right: 15px; cursor: pointer; color: #aaa; font-size: 1.5rem; }
        .close-modal:hover { color: #fff; }

        .upg-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; background: rgba(0,0,0,0.3); padding: 15px; border-radius: 6px; border: 1px solid #333;}
        .upg-info { flex-grow: 1; }
        .upg-title { font-weight: bold; font-size: 1rem; color: #fff; margin-bottom: 4px; }
        .upg-desc { font-size: 0.75rem; color: #aaa; }
        .upg-lvl { color: #f39c12; font-size: 0.8rem; font-weight: bold; margin-top: 4px; }
        .upg-btn { background: #4db8ff; color: #000; padding: 8px 15px; border:none; cursor: pointer; border-radius: 4px; font-weight: bold; transition: 0.2s; min-width: 90px; text-align: center; }
        .upg-btn:hover { background: #fff; }
        .upg-btn:disabled { background: #444; color: #888; cursor: not-allowed; }

        /* Sorter Modal Specifics */
        #sorter-modal { width: 380px; border-color: #3498db; }
        #sorter-modal h2 { color: #3498db; }
        .sorter-header { display: flex; justify-content: space-between; padding: 0 10px 10px 10px; font-size: 0.8rem; color: #888; font-weight: bold;}
        .sorter-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; background: rgba(0,0,0,0.3); padding: 8px 10px; border-radius: 6px; border: 1px solid #333;}
        .sorter-res { font-size: 0.85rem; color: #ddd; padding-left: 10px; flex-grow: 1;}
        .sorter-btns { display: flex; gap: 5px; }
        .s-btn { width: 32px; height: 32px; background: #222; border: 1px solid #555; color: #aaa; border-radius: 4px; cursor: pointer; transition: 0.2s; font-weight:bold; }
        .s-btn:hover { background: #444; color: #fff; }
        .s-btn.active { background: #3498db; color: #fff; border-color: #fff; box-shadow: 0 0 8px rgba(52, 152, 219, 0.6);}

    </style>
</head>
<body>

    <div id="notification">Jeu Sauvegard√©</div>

    <div id="boss-screen">
        <h2 style="color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px;">Monitoring des Flux Serveurs - Cluster Alpha</h2>
        <div style="margin-bottom: 20px; font-size: 14px; color: #7f8c8d;">Last Sync: <span id="fake-time"></span> | User: Admin</div>
        <table class="fake-table">
            <thead>
                <tr><th>PID</th><th>Service</th><th>Status</th><th>Memory (MB)</th><th>Uptime</th></tr>
            </thead>
            <tbody id="fake-table-body"></tbody>
        </table>
    </div>

    <!-- Modals -->
    <div id="upgrade-modal" class="modal">
        <span class="close-modal" onclick="toggleUpgrades()">&times;</span>
        <h2>Centre de Recherche</h2>
        
        <div class="upg-row">
            <div class="upg-info">
                <div class="upg-title">Overclocking Extracteurs</div>
                <div class="upg-desc">Augmente la vitesse de minage de toutes les foreuses.</div>
                <div class="upg-lvl" id="lvl-miner">Niveau: 0/5</div>
            </div>
            <button class="upg-btn" id="btn-upg-miner" onclick="buyUpgrade('miner')">1000 ¬¢</button>
        </div>
        
        <div class="upg-row">
            <div class="upg-info">
                <div class="upg-title">Moteurs Magn√©tiques</div>
                <div class="upg-desc">Augmente la vitesse de d√©placement sur les convoyeurs.</div>
                <div class="upg-lvl" id="lvl-belt">Niveau: 0/5</div>
            </div>
            <button class="upg-btn" id="btn-upg-belt" onclick="buyUpgrade('belt')">1000 ¬¢</button>
        </div>
        
        <div class="upg-row">
            <div class="upg-info">
                <div class="upg-title">N√©gociation de Flux</div>
                <div class="upg-desc">Augmente le prix de revente au Core (+50% par niveau).</div>
                <div class="upg-lvl" id="lvl-value">Niveau: 0/5</div>
            </div>
            <button class="upg-btn" id="btn-upg-value" onclick="buyUpgrade('value')">2500 ¬¢</button>
        </div>
    </div>

    <div id="sorter-modal" class="modal">
        <span class="close-modal" onclick="document.getElementById('sorter-modal').style.display='none'">&times;</span>
        <h2>Filtres du Trieur</h2>
        <div class="sorter-header">
            <div>Type de Ressource</div>
            <div style="display:flex; gap:5px; text-align:center;">
                <span style="width:32px" title="Gauche">G</span><span style="width:32px" title="Face">F</span><span style="width:32px" title="Droite">D</span>
            </div>
        </div>
        <div id="sorter-filters-container"></div>
    </div>

    <!-- Interface du jeu -->
    <div id="ui-layer">
        <div class="panel-container">
            <div class="panel">
                <div class="header-flex">
                    <h1>LogiNode v13.0</h1>
                    <div>
                        <button class="sys-btn" onclick="toggleUpgrades()" style="margin-right: 5px; background: #2980b9; color:#fff; border-color:#3498db;">UPGRADES</button>
                        <button class="sys-btn danger" onclick="resetGame()" title="Effacer la sauvegarde">RESET</button>
                    </div>
                </div>
                
                <div class="dashboard-grid">
                    <div class="stat-box mission-box" id="missionContainer">
                        <div class="stat-label" id="missionTitle" style="color: #4db8ff; font-weight:bold;">Phase 1: Initialisation</div>
                        <div style="font-size: 0.8rem; margin-top: 4px; line-height: 1.3;" id="missionDesc">Desc</div>
                        <div style="display: flex; align-items: center; gap: 10px; margin-top: 8px;">
                            <div style="flex-grow: 1; background: #111; height: 8px; border-radius: 4px; overflow: hidden; border: 1px solid #333;">
                                <div id="missionBar" style="background: #4db8ff; height: 100%; width: 0%; transition: width 0.3s;"></div>
                            </div>
                            <div id="missionText" style="font-size: 0.8rem; font-weight: bold; width: 45px; text-align: right;">0 / 20</div>
                        </div>
                    </div>

                    <div class="stat-box">
                        <div class="stat-label">Budget</div>
                        <div class="stat-value" id="moneyDisplay">1000 ¬¢</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Flux / Min</div>
                        <div class="stat-value cyan" id="ipmDisplay">0</div>
                    </div>
                    <div class="stat-box" style="grid-column: span 2;">
                        <div class="stat-label">√ânergie (Prod / Cons)</div>
                        <div class="stat-value power-ok" id="powerDisplay">50 / 0 W</div>
                    </div>
                </div>
                
                <div class="toolbar" id="toolbar-main">
                    <button class="btn active" onclick="setBuildMode('cursor')">
                        <span style="width:12px;height:12px;background:#ccc;border-radius:50%;display:inline-block;"></span>
                        Inspecter <span class="shortcut">1</span>
                    </button>
                    <button class="btn" onclick="setBuildMode('pan')">
                        <span style="width:12px;height:12px;background:none;border:2px solid #fff;border-radius:50%;display:inline-block;position:relative;"><span style="position:absolute;top:-6px;left:1px;">+</span></span>
                        Cam√©ra <span class="shortcut">M</span>
                    </button>
                    
                    <hr style="border-color:#333; width:100%; margin: 2px 0;">
                    
                    <button class="btn" onclick="setBuildMode('miner')" id="btn-miner">
                        <span style="width:12px;height:12px;background:#e74c3c;display:inline-block;"></span>
                        Extracteur <span style="color:#aaa;font-size:0.7rem;">(100¬¢ / 10W)</span> <span class="shortcut">2</span>
                    </button>
                    <button class="btn" onclick="setBuildMode('belt')" id="btn-belt">
                        <span style="width:12px;height:12px;background:#95a5a6;display:inline-block;text-align:center;line-height:12px;font-size:10px;color:#000;">‚Üë</span>
                        Convoyeur <span style="color:#aaa;font-size:0.7rem;">(15¬¢)</span> <span class="shortcut">3</span>
                    </button>
                    <button class="btn" onclick="setBuildMode('tunnel')" id="btn-tunnel" style="display:none;">
                        <span style="width:12px;height:12px;background:#2c3e50;display:inline-block;text-align:center;line-height:12px;font-size:10px;color:#fff;border-radius:2px;">U</span>
                        Tunnel <span style="color:#aaa;font-size:0.7rem;">(250¬¢)</span> <span class="shortcut">4</span>
                    </button>
                    <button class="btn" onclick="setBuildMode('splitter')" id="btn-splitter" style="display:none;">
                        <span style="width:12px;height:12px;background:#1abc9c;display:inline-block;text-align:center;line-height:12px;font-size:10px;color:#000;">Y</span>
                        R√©partiteur <span style="color:#aaa;font-size:0.7rem;">(100¬¢)</span> <span class="shortcut">5</span>
                    </button>
                    <button class="btn" onclick="setBuildMode('sorter')" id="btn-sorter" style="display:none;">
                        <span style="width:12px;height:12px;background:#3498db;display:inline-block;text-align:center;line-height:12px;font-size:10px;color:#fff;">S</span>
                        Trieur <span style="color:#aaa;font-size:0.7rem;">(300¬¢ / 5W)</span> <span class="shortcut">6</span>
                    </button>
                    <button class="btn" onclick="setBuildMode('upgrader')" id="btn-upgrader" style="display:none;">
                        <span style="width:12px;height:12px;background:#e67e22;display:inline-block;"></span>
                        Traitement <span style="color:#aaa;font-size:0.7rem;">(250¬¢ / 15W)</span> <span class="shortcut">7</span>
                    </button>
                    <button class="btn" onclick="setBuildMode('assembler')" id="btn-assembler" style="display:none;">
                        <span style="width:12px;height:12px;background:#8e44ad;display:inline-block;"></span>
                        Assembleur <span style="color:#aaa;font-size:0.7rem;">(800¬¢ / 30W)</span> <span class="shortcut">8</span>
                    </button>
                    <button class="btn" onclick="setBuildMode('integrator')" id="btn-integrator" style="display:none;">
                        <span style="width:12px;height:12px;background:#ecf0f1;display:inline-block;border:1px solid #333;"></span>
                        Int√©grateur <span style="color:#aaa;font-size:0.7rem;">(1500¬¢ / 50W)</span> <span class="shortcut">9</span>
                    </button>
                    <button class="btn" onclick="setBuildMode('compressor')" id="btn-compressor" style="display:none; border-color:#000;">
                        <span style="width:12px;height:12px;background:#000;display:inline-block;border:1px solid #fff;"></span>
                        Compresseur <span style="color:#aaa;font-size:0.7rem;">(3000¬¢ / 150W)</span> <span class="shortcut">C</span>
                    </button>

                    <hr id="hr-security" style="border-color:#333; width:100%; margin: 2px 0; display:none;">
                    
                    <button class="btn" onclick="setBuildMode('hub')" id="btn-hub" style="display:none; border-color:#3498db;">
                        <span style="width:12px;height:12px;background:#3498db;display:inline-block;text-align:center;line-height:12px;font-size:10px;color:#fff;">H</span>
                        Relais Export <span style="color:#aaa;font-size:0.7rem;">(5000¬¢ / 100W)</span> <span class="shortcut">H</span>
                    </button>
                    <button class="btn" onclick="setBuildMode('generator')" id="btn-generator" style="display:none; border-color:#f1c40f;">
                        <span style="width:12px;height:12px;background:#f1c40f;display:inline-block;text-align:center;line-height:12px;font-size:10px;color:#000;">‚ö°</span>
                        G√©n√©rateur <span style="color:#aaa;font-size:0.7rem;">(500¬¢ / +100W)</span> <span class="shortcut">G</span>
                    </button>
                    <button class="btn" onclick="setBuildMode('firewall')" id="btn-firewall" style="display:none; border-color:#e74c3c;">
                        <span style="width:12px;height:12px;background:#c0392b;display:inline-block;text-align:center;line-height:12px;font-size:10px;color:#fff;">‚ôú</span>
                        Firewall <span style="color:#aaa;font-size:0.7rem;">(800¬¢ / 20W)</span> <span class="shortcut">F</span>
                    </button>
                    
                    <hr style="border-color:#333; width:100%; margin: 2px 0;">

                    <button class="btn" onclick="setBuildMode('trash')" id="btn-trash" style="display:none;">
                        <span style="width:12px;height:12px;background:#c0392b;display:inline-block;text-align:center;line-height:12px;font-size:10px;color:#fff;">üóë</span>
                        /dev/null <span style="color:#aaa;font-size:0.7rem;">(50¬¢)</span> <span class="shortcut">0</span>
                    </button>
                    <button class="btn" onclick="setBuildMode('delete')">
                        <span style="width:12px;height:12px;background:repeating-linear-gradient(45deg, #000, #000 2px, #e74c3c 2px, #e74c3c 4px);display:inline-block;"></span>
                        D√©molir (Clic Droit) <span class="shortcut">X</span>
                    </button>
                </div>

                <div class="tutorial">
                    <strong>Nouveaut√©s V13 :</strong><br>
                    - üì¶ <strong>Gisements x10 :</strong> Les filons contiennent 10 fois plus de minerai.<br>
                    - üîé <strong>Scanner :</strong> Survolez un gisement pour voir ce qu'il lui reste.<br>
                    - üì° <strong>Relais (H) :</strong> Un 2√®me point de livraison pour vos grandes usines.
                </div>
            </div>
        </div>
        
        <div class="panel" style="height: fit-content; min-width: 150px;">
            <div style="font-size: 0.75rem; color: #888; text-transform: uppercase;">Orientation (Touche R)</div>
            <div id="dirDisplay" style="color: #fff; font-size: 1.3rem; font-weight: bold; margin: 5px 0;">HAUT (‚Üë)</div>
            <div style="font-size: 0.7rem; color: #666; border-top: 1px solid #333; padding-top: 5px; margin-top: 10px;" id="coordsDisplay">
                X:0, Y:0
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const TILE_SIZE = 40;
        const CHUNK_SIZE = 10; // 10x10 tiles per chunk
        
        const DIRS = [
            { x: 0, y: -1, symbol: '‚Üë', name: 'HAUT' },
            { x: 1, y: 0, symbol: '‚Üí', name: 'DROITE' },
            { x: 0, y: 1, symbol: '‚Üì', name: 'BAS' },
            { x: -1, y: 0, symbol: '‚Üê', name: 'GAUCHE' }
        ];

        // Consommation √©lectrique
        const POWER_USAGE = {
            'miner': 10, 'upgrader': 15, 'assembler': 30, 'integrator': 50, 'compressor': 150, 'sorter': 5, 'firewall': 20, 'hub': 100
        };

        // --- ETAT DU JEU ---
        const game = {
            money: 1000, 
            gridWidth: 100, gridHeight: 100, // 10x10 chunks
            grid: [], items: [], deliveries: [], particles: [],
            enemies: [], lasers: [],
            
            unlockedChunks: new Set(), // Set of "cx,cy" strings
            
            power: { produced: 50, consumed: 0, efficiency: 1.0 },
            upgrades: { miner: 0, belt: 0, value: 0 },
            selectedSorter: null,
            
            missionIndex: 0, missionProgress: 0,
            missions: [
                { title: "Phase 1: Donn√©es Brutes", desc: "Acheminez 50 Flux Donn√©es (Bleu) au Core.", type: 'raw_blue', req: 50 },
                { title: "Phase 2: Logistique", desc: "Acheminez 100 Flux Trait√©s (Vert).\n<span style='color:#2ecc71'>D√©bloque: Traitement, Tunnel, R√©partiteur.</span>", type: 'proc_blue', req: 100 },
                { title: "Phase 3: S√âCURIT√â", desc: "ALERTE: Virus d√©tect√©s !\nProduisez 75 Violets (Assembleur).\n<span style='color:#e74c3c'>N√©cessite de l'√ânergie et des Firewalls.</span>", type: 'advanced_purple', req: 75 },
                { title: "Phase 4: Int√©gration", desc: "Nouveaux gisements: Quantique (Rose).\nCombinez Violet + Rose dans l'Int√©grateur.\n<span style='color:#2ecc71'>D√©bloque: Int√©grateur, Mine Rose, Hub Export.</span>", type: 'omega', req: 50 },
                { title: "Phase 5: Ma√Ætrise Quantique", desc: "Forgez la Mati√®re Sombre.\n<span style='color:#2ecc71'>D√©bloque: Compresseur (3 Omegas = 1 Singularit√©).</span>\nLivrez 25 Singularit√©s (Noir).", type: 'singularity', req: 25 },
                { title: "Phase 6: Infinie", desc: "Syst√®me optimis√©. Survivez et maximisez les profits.", type: 'none', req: 0 }
            ],
            
            buildMode: 'cursor', currentDir: 0,
            camera: { x: 0, y: 0 }, zoom: 1.0,
            mouseX: 0, mouseY: 0, worldX: 0, worldY: 0,
            paintButton: null, isMiddleDragging: false, lastMouse: { x: 0, y: 0 },
            keys: {}, tick: 0, core: { x: 50, y: 50 }
        };

        class Tile {
            constructor(x, y) { this.x = x; this.y = y; this.resource = null; this.building = null; }
        }

        class Item {
            constructor(startX, startY, type) {
                this.x = startX; this.y = startY; this.progress = 0;
                this.gridX = startX; this.gridY = startY; this.movingDir = -1; this.type = type; 
            }
        }

        class Particle {
            constructor(x, y, text, color) {
                this.x = x; this.y = y; this.text = text; this.color = color;
                this.life = 60; this.maxLife = 60;
            }
        }

        class Enemy {
            constructor(x, y, hp) {
                this.x = x; this.y = y; this.hp = hp; this.maxHp = hp;
                this.speed = 0.03 + Math.random() * 0.03; 
            }
        }

        // --- UPGRADES & TRIEUR ---
        function getUpgradeCost(type) {
            let lvl = game.upgrades[type];
            if(lvl >= 5) return Infinity;
            if(type === 'value') return 2500 * Math.pow(2, lvl); 
            return 1000 * Math.pow(2, lvl);
        }

        function toggleUpgrades() {
            let m = document.getElementById('upgrade-modal');
            if (m.style.display === 'block') { m.style.display = 'none'; return; }
            updateUpgradeUI(); m.style.display = 'block';
        }

        function updateUpgradeUI() {
            ['miner', 'belt', 'value'].forEach(type => {
                let lvl = game.upgrades[type]; let cost = getUpgradeCost(type);
                document.getElementById(`lvl-${type}`).innerText = `Niveau: ${lvl}/5`;
                let btn = document.getElementById(`btn-upg-${type}`);
                if (lvl >= 5) { btn.innerText = "MAX"; btn.disabled = true; } 
                else { btn.innerText = cost + " ¬¢"; btn.disabled = (game.money < cost); }
            });
        }

        function buyUpgrade(type) {
            let cost = getUpgradeCost(type);
            if (game.money >= cost && game.upgrades[type] < 5) {
                game.money -= cost; game.upgrades[type]++;
                updateUpgradeUI(); updateUI(); saveGame();
            }
        }

        const RESOURCES = [
            { id: 'raw_blue', name: 'Bleu', color: '#00d2ff' }, { id: 'proc_blue', name: 'Vert', color: '#2ecc71' },
            { id: 'raw_orange', name: 'Orange', color: '#ff9f43' }, { id: 'proc_orange', name: 'Jaune', color: '#feca57' },
            { id: 'advanced_purple', name: 'Violet', color: '#9b59b6' }, { id: 'raw_pink', name: 'Rose', color: '#fd79a8' },
            { id: 'omega', name: 'Blanc', color: '#ffffff' }, { id: 'singularity', name: 'Noir', color: '#000000' }
        ];

        function openSorterConfig(x, y) {
            game.selectedSorter = {x, y};
            let b = game.grid[x][y].building;
            if(!b.filters) b.filters = { left: ['raw_blue', 'proc_blue'], straight: ['raw_orange', 'proc_orange'], right: ['raw_pink', 'advanced_purple', 'omega', 'singularity'] };
            updateSorterUI(); document.getElementById('sorter-modal').style.display = 'block';
        }

        function updateSorterUI() {
            if(!game.selectedSorter) return;
            let b = game.grid[game.selectedSorter.x][game.selectedSorter.y].building;
            let container = document.getElementById('sorter-filters-container');
            let html = '';
            RESOURCES.forEach(res => {
                let isLeft = b.filters.left.includes(res.id) ? 'active' : '';
                let isStraight = b.filters.straight.includes(res.id) ? 'active' : '';
                let isRight = b.filters.right.includes(res.id) ? 'active' : '';
                html += `<div class="sorter-row"><div class="sorter-res" style="border-left: 4px solid ${res.color};">${res.name}</div>
                    <div class="sorter-btns"><button class="s-btn ${isLeft}" onclick="setSorterFilter('${res.id}', 'left')">‚Üê</button>
                        <button class="s-btn ${isStraight}" onclick="setSorterFilter('${res.id}', 'straight')">‚Üë</button>
                        <button class="s-btn ${isRight}" onclick="setSorterFilter('${res.id}', 'right')">‚Üí</button></div></div>`;
            });
            container.innerHTML = html;
        }

        function setSorterFilter(resId, dir) {
            if(!game.selectedSorter) return;
            let b = game.grid[game.selectedSorter.x][game.selectedSorter.y].building;
            let wasInDir = b.filters[dir].includes(resId);
            b.filters.left = b.filters.left.filter(r => r !== resId);
            b.filters.straight = b.filters.straight.filter(r => r !== resId);
            b.filters.right = b.filters.right.filter(r => r !== resId);
            if(!wasInDir) b.filters[dir].push(resId);
            updateSorterUI(); saveGame(); 
        }

        // --- SAUVEGARDE ET CHUNKS ---
        function saveGame() {
            let saveData = {
                money: game.money, missionIndex: game.missionIndex, missionProgress: game.missionProgress, zoom: game.zoom,
                upgrades: game.upgrades, unlockedChunks: Array.from(game.unlockedChunks), gridData: []
            };
            for(let x=0; x<game.gridWidth; x++) {
                for(let y=0; y<game.gridHeight; y++) {
                    let t = game.grid[x][y];
                    if(t.resource || t.building) saveData.gridData.push({x: x, y: y, r: t.resource, b: t.building});
                }
            }
            localStorage.setItem('loginode_save_v13', JSON.stringify(saveData));
        }

        function loadGame() {
            let saved = localStorage.getItem('loginode_save_v13'); 
            // Fallback pour ne pas casser la partie de V12 √† V13
            if(!saved) saved = localStorage.getItem('loginode_save_v12'); 

            if(saved) {
                try {
                    let data = JSON.parse(saved);
                    game.money = data.money; game.missionIndex = data.missionIndex || 0;
                    game.missionProgress = data.missionProgress || 0; game.zoom = data.zoom || 1.0;
                    if(data.upgrades) game.upgrades = data.upgrades;
                    if(data.unlockedChunks) game.unlockedChunks = new Set(data.unlockedChunks);
                    
                    game.grid = [];
                    for (let x = 0; x < game.gridWidth; x++) {
                        game.grid[x] = [];
                        for (let y = 0; y < game.gridHeight; y++) game.grid[x][y] = new Tile(x, y);
                    }
                    data.gridData.forEach(d => {
                        if(game.grid[d.x] && game.grid[d.x][d.y]) {
                            game.grid[d.x][d.y].resource = d.r; game.grid[d.x][d.y].building = d.b;
                        }
                    });
                    
                    game.camera.x = Math.floor(window.innerWidth / 2 - (game.core.x * TILE_SIZE * game.zoom + (TILE_SIZE*game.zoom) / 2));
                    game.camera.y = Math.floor(window.innerHeight / 2 - (game.core.y * TILE_SIZE * game.zoom + (TILE_SIZE*game.zoom) / 2));
                    return true;
                } catch(e) { console.error(e); }
            }
            return false;
        }

        function resetGame() {
            if(confirm("√ätes-vous s√ªr de vouloir effacer votre sauvegarde ?")) {
                localStorage.clear(); location.reload();
            }
        }

        function getChunkCost() {
            return game.unlockedChunks.size * 1000; 
        }

        function isChunkUnlocked(gx, gy) {
            let cx = Math.floor(gx / CHUNK_SIZE);
            let cy = Math.floor(gy / CHUNK_SIZE);
            return game.unlockedChunks.has(`${cx},${cy}`);
        }

        function isChunkAdjacentToUnlocked(cx, cy) {
            return game.unlockedChunks.has(`${cx-1},${cy}`) || game.unlockedChunks.has(`${cx+1},${cy}`) ||
                   game.unlockedChunks.has(`${cx},${cy-1}`) || game.unlockedChunks.has(`${cx},${cy+1}`);
        }

        // --- INITIALISATION ---
        function initGrid() {
            game.grid = [];
            for (let x = 0; x < game.gridWidth; x++) {
                game.grid[x] = [];
                for (let y = 0; y < game.gridHeight; y++) game.grid[x][y] = new Tile(x, y);
            }
            
            game.grid[game.core.x][game.core.y].building = { type: 'core' };
            game.camera.x = Math.floor(window.innerWidth / 2 - (game.core.x * TILE_SIZE * game.zoom + (TILE_SIZE*game.zoom) / 2));
            game.camera.y = Math.floor(window.innerHeight / 2 - (game.core.y * TILE_SIZE * game.zoom + (TILE_SIZE*game.zoom) / 2));

            let coreCx = Math.floor(game.core.x / CHUNK_SIZE);
            let coreCy = Math.floor(game.core.y / CHUNK_SIZE);
            for(let i=-1; i<=1; i++){
                for(let j=-1; j<=1; j++){
                    game.unlockedChunks.add(`${coreCx+i},${coreCy+j}`);
                }
            }

            // G√©n√©ration de gisements x10 (V13)
            let nodesPlaced = 0;
            while(nodesPlaced < 200) {
                let rx = Math.floor(Math.random() * game.gridWidth), ry = Math.floor(Math.random() * game.gridHeight);
                let dist = Math.abs(rx - game.core.x) + Math.abs(ry - game.core.y);
                if (dist > 4 && !game.grid[rx][ry].resource) {
                    let rand = Math.random();
                    let type = 'node_blue';
                    let amt = Math.floor(Math.random() * 5000) + 3000; // 3000 √† 8000
                    
                    if(rand > 0.8) { type = 'node_pink'; amt = Math.floor(Math.random() * 3000) + 1500; }
                    else if(rand > 0.5) { type = 'node_orange'; amt = Math.floor(Math.random() * 4000) + 2000; }
                    
                    game.grid[rx][ry].resource = { type: type, amount: amt, max: amt };
                    nodesPlaced++;
                }
            }
        }

        function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }

        function isUnlocked(mode) {
            if (['splitter', 'upgrader', 'tunnel', 'trash'].includes(mode)) return game.missionIndex >= 1;
            if (['assembler', 'sorter', 'generator', 'firewall'].includes(mode)) return game.missionIndex >= 2;
            if (['integrator', 'hub'].includes(mode)) return game.missionIndex >= 3;
            if (mode === 'compressor') return game.missionIndex >= 4;
            return true;
        }

        function tryBuild(gx, gy, isRightClick) {
            if (gx < 0 || gx >= game.gridWidth || gy < 0 || gy >= game.gridHeight) return;
            
            let cx = Math.floor(gx / CHUNK_SIZE); let cy = Math.floor(gy / CHUNK_SIZE);
            if (!game.unlockedChunks.has(`${cx},${cy}`)) return; 

            let tile = game.grid[gx][gy];

            if (game.buildMode === 'delete' || isRightClick) {
                if (tile.building && tile.building.type !== 'core') {
                    let wasGen = tile.building.type === 'generator' || tile.building.type === 'hub';
                    tile.building = null;
                    if (wasGen) calculatePower();
                }
                return;
            }

            if (tile.building || game.buildMode === 'cursor' || game.buildMode === 'pan') return;
            if (!isUnlocked(game.buildMode)) return;

            const costs = { 'miner': 100, 'belt': 15, 'upgrader': 250, 'assembler': 800, 'splitter': 100, 'sorter': 300, 'integrator': 1500, 'compressor': 3000, 'tunnel': 250, 'trash': 50, 'generator': 500, 'firewall': 800, 'hub': 5000 };
            
            if (game.money >= costs[game.buildMode]) {
                if (game.buildMode === 'miner') {
                    if (!tile.resource) return;
                    if (tile.resource.type === 'node_orange' && game.missionIndex < 2) return;
                    if (tile.resource.type === 'node_pink' && game.missionIndex < 3) return;
                }
                
                game.money -= costs[game.buildMode];
                let bData = { type: game.buildMode, dir: game.currentDir };
                
                if (game.buildMode === 'assembler') bData.inventory = { proc_blue: 0, proc_orange: 0 };
                if (game.buildMode === 'integrator') bData.inventory = { advanced_purple: 0, raw_pink: 0 };
                if (game.buildMode === 'compressor') bData.inventory = { omega: 0 };
                if (game.buildMode === 'splitter') bData.toggle = false;
                if (game.buildMode === 'sorter') bData.filters = { left: ['raw_blue', 'proc_blue'], straight: ['raw_orange', 'proc_orange'], right: ['raw_pink', 'advanced_purple', 'omega', 'singularity'] };
                
                tile.building = bData;
                calculatePower(); updateUI();
                if(document.getElementById('upgrade-modal').style.display === 'block') updateUpgradeUI();
            }
        }

        // --- GESTION ENERGIE ---
        function calculatePower() {
            let prod = 50; 
            let cons = 0;
            for (let x = 0; x < game.gridWidth; x++) {
                for (let y = 0; y < game.gridHeight; y++) {
                    let b = game.grid[x][y].building;
                    if (b) {
                        if (b.type === 'generator') prod += 100;
                        if (POWER_USAGE[b.type]) cons += POWER_USAGE[b.type];
                    }
                }
            }
            game.power.produced = prod; game.power.consumed = cons;
            game.power.efficiency = cons > 0 ? Math.min(1.0, prod / cons) : 1.0;
            updateUI();
        }

        // --- LOGIQUE METIER ---
        function update() {
            if (document.getElementById('boss-screen').style.display === 'block') return;
            game.tick++;

            if (game.tick > 0 && game.tick % 600 === 0) saveGame();
            if (game.tick % 60 === 0) calculatePower();

            const camSpeed = 12;
            if (game.keys['ArrowUp'] || game.keys['z'] || game.keys['w']) game.camera.y += camSpeed;
            if (game.keys['ArrowDown'] || game.keys['s']) game.camera.y -= camSpeed;
            if (game.keys['ArrowLeft'] || game.keys['q'] || game.keys['a']) game.camera.x += camSpeed;
            if (game.keys['ArrowRight'] || game.keys['d']) game.camera.x -= camSpeed;

            // 1. Minage (√âpuisement)
            let minerInterval = Math.max(10, 60 - (game.upgrades.miner * 10)); 
            if (game.power.efficiency > 0 && game.tick % Math.floor(minerInterval / game.power.efficiency) === 0) {
                for (let x = 0; x < game.gridWidth; x++) {
                    for (let y = 0; y < game.gridHeight; y++) {
                        let tile = game.grid[x][y];
                        if (tile.building && tile.building.type === 'miner' && tile.resource) {
                            let itemOnTile = game.items.find(i => Math.round(i.x) === x && Math.round(i.y) === y);
                            if (!itemOnTile) {
                                let tStr = tile.resource.type.replace('node_', 'raw_');
                                game.items.push(new Item(x, y, tStr));
                                
                                tile.resource.amount--;
                                if(tile.resource.amount <= 0) {
                                    tile.resource = null; 
                                    game.particles.push(new Particle(x*TILE_SIZE, y*TILE_SIZE, "√âPUIS√â", "#e74c3c"));
                                    tile.building = null; 
                                }
                            }
                        }
                    }
                }
            }

            // 2. Gestion des Menaces
            if (game.missionIndex >= 2 && game.tick % 180 === 0) { 
                let spawnChance = Math.min(0.5, 0.1 * game.missionIndex);
                if (Math.random() < spawnChance) {
                    let ex = Math.random() < 0.5 ? (Math.random() < 0.5 ? 0 : game.gridWidth - 1) : Math.random() * game.gridWidth;
                    let ey = ex === 0 || ex === game.gridWidth - 1 ? Math.random() * game.gridHeight : (Math.random() < 0.5 ? 0 : game.gridHeight - 1);
                    game.enemies.push(new Enemy(ex, ey, 100 * (game.missionIndex - 1))); 
                }
            }

            for (let i = game.enemies.length - 1; i >= 0; i--) {
                let e = game.enemies[i];
                let dx = game.core.x - e.x; let dy = game.core.y - e.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > 0) { e.x += (dx/dist) * e.speed; e.y += (dy/dist) * e.speed; }

                let gx = Math.round(e.x), gy = Math.round(e.y);
                if (gx >= 0 && gx < game.gridWidth && gy >= 0 && gy < game.gridHeight) {
                    let b = game.grid[gx][gy].building;
                    if (b && b.type !== 'core' && b.type !== 'hub') {
                        game.grid[gx][gy].building = null;
                        game.particles.push(new Particle(gx * TILE_SIZE, gy * TILE_SIZE, "CORROMPU", "#e74c3c"));
                        game.enemies.splice(i, 1);
                        calculatePower(); continue;
                    }
                }
            }

            // 3. D√©fenses (Firewalls)
            if (game.power.efficiency > 0.1 && game.tick % Math.floor(30 / game.power.efficiency) === 0) {
                for (let x = 0; x < game.gridWidth; x++) {
                    for (let y = 0; y < game.gridHeight; y++) {
                        let b = game.grid[x][y].building;
                        if (b && b.type === 'firewall') {
                            let closest = null; let minDist = 6;
                            for (let e of game.enemies) {
                                let dist = Math.sqrt(Math.pow(e.x - x, 2) + Math.pow(e.y - y, 2));
                                if (dist < minDist) { minDist = dist; closest = e; }
                            }
                            if (closest) {
                                game.lasers.push({ x1: x, y1: y, x2: closest.x, y2: closest.y, life: 10 });
                                closest.hp -= 50;
                                if (closest.hp <= 0) {
                                    game.particles.push(new Particle(closest.x * TILE_SIZE, closest.y * TILE_SIZE, "√âLIMIN√â", "#3498db"));
                                    game.enemies = game.enemies.filter(en => en !== closest);
                                }
                            }
                        }
                    }
                }
            }

            for(let i=game.lasers.length-1; i>=0; i--) { game.lasers[i].life--; if(game.lasers[i].life <= 0) game.lasers.splice(i, 1); }
            for(let i=game.particles.length-1; i>=0; i--) { game.particles[i].life -= 1.5; game.particles[i].y -= 0.5; if(game.particles[i].life <= 0) game.particles.splice(i, 1); }

            // 4. Mouvement des objets
            for (let i = game.items.length - 1; i >= 0; i--) {
                let item = game.items[i];
                let currentTile = game.grid[item.gridX] && game.grid[item.gridX][item.gridY];

                if (!currentTile) continue;

                if (item.progress === 0) {
                    if (currentTile.building) {
                        let b = currentTile.building;
                        
                        if (b.type === 'core' || b.type === 'hub') {
                            const baseValues = { 'raw_blue': 15, 'proc_blue': 40, 'raw_orange': 20, 'proc_orange': 50, 'advanced_purple': 200, 'raw_pink': 100, 'omega': 1000, 'singularity': 5000 };
                            let val = Math.floor((baseValues[item.type] || 0) * (1 + (game.upgrades.value * 0.5)));
                            
                            game.money += val; game.deliveries.push(Date.now());
                            game.particles.push(new Particle(item.x * TILE_SIZE + TILE_SIZE/2, item.y * TILE_SIZE + TILE_SIZE/2 - 10, `+${val}¬¢`, '#2ecc71'));
                            
                            let cm = game.missions[game.missionIndex];
                            if (cm.type === item.type) {
                                game.missionProgress++;
                                if (game.missionProgress >= cm.req) {
                                    game.missionIndex++; game.missionProgress = 0;
                                    let mc = document.getElementById('missionContainer');
                                    mc.style.backgroundColor = "rgba(46, 204, 113, 0.4)";
                                    setTimeout(() => { mc.style.backgroundColor = "rgba(77, 184, 255, 0.05)"; }, 500);
                                    setBuildMode('cursor');
                                }
                            }
                            updateUI();
                            if(document.getElementById('upgrade-modal').style.display === 'block') updateUpgradeUI();
                            game.items.splice(i, 1);
                            continue;
                        }
                        else if (b.type === 'trash') { game.particles.push(new Particle(item.x * TILE_SIZE, item.y * TILE_SIZE, `DEL`, '#e74c3c')); game.items.splice(i, 1); continue; }
                        else if (b.type === 'belt') { item.movingDir = b.dir; } 
                        else if (b.type === 'tunnel') {
                            let foundExit = false;
                            for(let dist=1; dist<=5; dist++) {
                                let nx = item.gridX + DIRS[b.dir].x * dist; let ny = item.gridY + DIRS[b.dir].y * dist;
                                let t = game.grid[nx] && game.grid[nx][ny];
                                if (t && t.building && t.building.type === 'tunnel' && t.building.dir === b.dir) {
                                    item.gridX = nx; item.gridY = ny; item.x = nx; item.y = ny; item.movingDir = b.dir; foundExit = true; break;
                                }
                            }
                            if(!foundExit) item.movingDir = b.dir;
                        }
                        else if (b.type === 'splitter') {
                            item.movingDir = b.toggle ? (b.dir + 3) % 4 : (b.dir + 1) % 4; b.toggle = !b.toggle;
                        }
                        else if (b.type === 'sorter') {
                            if(!b.filters) b.filters = { left: ['raw_blue', 'proc_blue'], straight: ['raw_orange', 'proc_orange'], right: ['raw_pink', 'advanced_purple', 'omega', 'singularity'] };
                            if (b.filters.left.includes(item.type)) item.movingDir = (b.dir + 3) % 4;
                            else if (b.filters.straight.includes(item.type)) item.movingDir = b.dir;
                            else if (b.filters.right.includes(item.type)) item.movingDir = (b.dir + 1) % 4;
                            else item.movingDir = -1; 
                        }
                        else if (b.type === 'upgrader') {
                            if (item.type === 'raw_blue') item.type = 'proc_blue';
                            else if (item.type === 'raw_orange') item.type = 'proc_orange';
                            item.movingDir = b.dir;
                        }
                        else if (b.type === 'assembler') {
                            if (item.type === 'proc_blue' && b.inventory.proc_blue < 1) {
                                b.inventory.proc_blue++;
                                if (b.inventory.proc_orange >= 1) { b.inventory.proc_blue = 0; b.inventory.proc_orange = 0; item.type = 'advanced_purple'; item.movingDir = b.dir; } 
                                else { game.items.splice(i, 1); continue; }
                            } else if (item.type === 'proc_orange' && b.inventory.proc_orange < 1) {
                                b.inventory.proc_orange++;
                                if (b.inventory.proc_blue >= 1) { b.inventory.proc_blue = 0; b.inventory.proc_orange = 0; item.type = 'advanced_purple'; item.movingDir = b.dir; } 
                                else { game.items.splice(i, 1); continue; }
                            } else item.movingDir = -1; 
                        }
                        else if (b.type === 'integrator') {
                            if (item.type === 'advanced_purple' && b.inventory.advanced_purple < 1) {
                                b.inventory.advanced_purple++;
                                if (b.inventory.raw_pink >= 1) { b.inventory.advanced_purple = 0; b.inventory.raw_pink = 0; item.type = 'omega'; item.movingDir = b.dir; } 
                                else { game.items.splice(i, 1); continue; }
                            } else if (item.type === 'raw_pink' && b.inventory.raw_pink < 1) {
                                b.inventory.raw_pink++;
                                if (b.inventory.advanced_purple >= 1) { b.inventory.advanced_purple = 0; b.inventory.raw_pink = 0; item.type = 'omega'; item.movingDir = b.dir; } 
                                else { game.items.splice(i, 1); continue; }
                            } else item.movingDir = -1; 
                        }
                        else if (b.type === 'compressor') {
                            if (item.type === 'omega') {
                                b.inventory.omega = (b.inventory.omega || 0) + 1;
                                if (b.inventory.omega >= 3) {
                                    b.inventory.omega = 0; item.type = 'singularity'; item.movingDir = b.dir;
                                } else { game.items.splice(i, 1); continue; }
                            } else item.movingDir = -1;
                        }
                        else if (b.type === 'generator' || b.type === 'firewall') {
                            item.movingDir = -1; 
                        }
                        else if (b.type === 'miner') {
                             let pushed = false;
                             for(let d=0; d<4; d++) {
                                 let nx = item.gridX + DIRS[d].x; let ny = item.gridY + DIRS[d].y; let adj = game.grid[nx] && game.grid[nx][ny];
                                 if(adj && adj.building && !['generator', 'firewall'].includes(adj.building.type)) { item.movingDir = d; pushed = true; break; }
                             }
                             if(!pushed) item.movingDir = -1;
                        }
                    } else item.movingDir = -1; 
                }

                if (item.movingDir !== -1) {
                    const baseSpeeds = { 'raw_blue': 0.06, 'proc_blue': 0.05, 'raw_orange': 0.06, 'proc_orange': 0.05, 'advanced_purple': 0.04, 'raw_pink': 0.04, 'omega': 0.03, 'singularity': 0.02 };
                    let speedMod = game.upgrades.belt * 0.015;
                    let currentSpeed = ((baseSpeeds[item.type] || 0.05) + speedMod) * Math.max(0.1, game.power.efficiency);
                    
                    item.progress += currentSpeed;
                    item.x = item.gridX + DIRS[item.movingDir].x * item.progress;
                    item.y = item.gridY + DIRS[item.movingDir].y * item.progress;

                    if (item.progress >= 1) {
                        item.gridX += DIRS[item.movingDir].x; item.gridY += DIRS[item.movingDir].y;
                        item.x = item.gridX; item.y = item.gridY; item.progress = 0; item.movingDir = -1;
                    }
                }
            }

            if (game.tick % 60 === 0) {
                let now = Date.now();
                game.deliveries = game.deliveries.filter(t => now - t < 60000);
                document.getElementById('ipmDisplay').innerText = game.deliveries.length;
            }
        }

        // --- RENDU VISUEL ---
        function draw() {
            ctx.fillStyle = '#1a1a20';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save(); 
            ctx.translate(game.camera.x, game.camera.y);
            ctx.scale(game.zoom, game.zoom);

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)'; 
            ctx.lineWidth = 1 / game.zoom;
            let startX = Math.max(0, Math.floor(-game.camera.x / (TILE_SIZE * game.zoom))); 
            let startY = Math.max(0, Math.floor(-game.camera.y / (TILE_SIZE * game.zoom)));
            let endX = Math.min(game.gridWidth, startX + Math.ceil(canvas.width / (TILE_SIZE * game.zoom)) + 1); 
            let endY = Math.min(game.gridHeight, startY + Math.ceil(canvas.height / (TILE_SIZE * game.zoom)) + 1);

            for (let x = startX; x <= endX; x++) { ctx.beginPath(); ctx.moveTo(x * TILE_SIZE, startY * TILE_SIZE); ctx.lineTo(x * TILE_SIZE, endY * TILE_SIZE); ctx.stroke(); }
            for (let y = startY; y <= endY; y++) { ctx.beginPath(); ctx.moveTo(startX * TILE_SIZE, y * TILE_SIZE); ctx.lineTo(endX * TILE_SIZE, y * TILE_SIZE); ctx.stroke(); }

            // Dessin des Chunks (Brouillard de guerre)
            let startCX = Math.max(0, Math.floor(startX / CHUNK_SIZE));
            let endCX = Math.min(10, Math.ceil(endX / CHUNK_SIZE));
            let startCY = Math.max(0, Math.floor(startY / CHUNK_SIZE));
            let endCY = Math.min(10, Math.ceil(endY / CHUNK_SIZE));

            for (let x = startX; x < endX; x++) {
                for (let y = startY; y < endY; y++) {
                    let tile = game.grid[x][y]; let px = x * TILE_SIZE; let py = y * TILE_SIZE;

                    if (tile.resource) {
                        let ratio = tile.resource.amount / tile.resource.max;
                        let sOffset = (1 - ratio) * 10; 
                        
                        if (tile.resource.type === 'node_blue') {
                            ctx.fillStyle = '#2980b9'; ctx.fillRect(px + 4 + sOffset/2, py + 4 + sOffset/2, TILE_SIZE - 8 - sOffset, TILE_SIZE - 8 - sOffset);
                            ctx.fillStyle = '#1abc9c'; ctx.fillRect(px + 8 + sOffset/2, py + 8 + sOffset/2, 8, 8);
                        } else if (tile.resource.type === 'node_orange') {
                            ctx.fillStyle = '#d35400'; ctx.fillRect(px + 4 + sOffset/2, py + 4 + sOffset/2, TILE_SIZE - 8 - sOffset, TILE_SIZE - 8 - sOffset);
                            ctx.fillStyle = '#f39c12'; ctx.fillRect(px + 8 + sOffset/2, py + 8 + sOffset/2, 8, 8);
                            if(game.missionIndex < 2) { ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(px+4, py+4, TILE_SIZE-8, TILE_SIZE-8); ctx.fillStyle='#fff'; ctx.font='10px Arial'; ctx.fillText('üîí', px+15, py+23); }
                        } else if (tile.resource.type === 'node_pink') {
                            ctx.fillStyle = '#8e44ad'; ctx.fillRect(px + 4 + sOffset/2, py + 4 + sOffset/2, TILE_SIZE - 8 - sOffset, TILE_SIZE - 8 - sOffset);
                            ctx.fillStyle = '#e84393'; ctx.fillRect(px + 8 + sOffset/2, py + 8 + sOffset/2, 8, 8);
                            if(game.missionIndex < 3) { ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(px+4, py+4, TILE_SIZE-8, TILE_SIZE-8); ctx.fillStyle='#fff'; ctx.font='10px Arial'; ctx.fillText('üîí', px+15, py+23); }
                        }
                        
                        ctx.fillStyle = '#333'; ctx.fillRect(px+4, py+TILE_SIZE-6, TILE_SIZE-8, 3);
                        ctx.fillStyle = ratio > 0.3 ? '#2ecc71' : '#e74c3c'; ctx.fillRect(px+4, py+TILE_SIZE-6, (TILE_SIZE-8)*ratio, 3);
                    }

                    if (tile.building) {
                        let b = tile.building;
                        
                        if (b.type === 'core') {
                            ctx.fillStyle = '#f1c40f'; ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            ctx.fillStyle = '#000'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('CORE', px + TILE_SIZE/2, py + TILE_SIZE/2);
                        } 
                        else if (b.type === 'hub') {
                            ctx.fillStyle = '#3498db'; ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            ctx.fillStyle = '#fff'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('HUB', px + TILE_SIZE/2, py + TILE_SIZE/2);
                        }
                        else if (b.type === 'generator') {
                            ctx.fillStyle = '#f1c40f'; ctx.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                            ctx.fillStyle = '#000'; ctx.font = '20px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('‚ö°', px + TILE_SIZE/2, py + TILE_SIZE/2);
                        }
                        else if (b.type === 'firewall') {
                            ctx.fillStyle = '#c0392b'; ctx.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                            ctx.fillStyle = '#fff'; ctx.font = '20px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('‚ôú', px + TILE_SIZE/2, py + TILE_SIZE/2);
                        }
                        else if (b.type === 'trash') {
                            ctx.fillStyle = '#c0392b'; ctx.fillRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                            ctx.fillStyle = '#000'; ctx.fillRect(px + 8, py + 8, TILE_SIZE - 16, TILE_SIZE - 16);
                            ctx.fillStyle = '#e74c3c'; ctx.font = '10px Arial'; ctx.textAlign='center'; ctx.fillText('NULL', px+TILE_SIZE/2, py+TILE_SIZE/2);
                        }
                        else if (b.type === 'belt') {
                            ctx.fillStyle = '#34495e'; ctx.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                            ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.save(); ctx.translate(px + TILE_SIZE/2, py + TILE_SIZE/2); ctx.rotate(b.dir * Math.PI / 2);
                            let offset = (game.tick % 20) / 20 * 10; ctx.font = '14px Arial'; ctx.fillText('‚Üë', 0, -5 + offset); ctx.fillText('‚Üë', 0, 10 + offset); ctx.restore();
                        }
                        else if (b.type === 'tunnel') {
                            ctx.fillStyle = '#2c3e50'; ctx.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                            ctx.fillStyle = '#000'; ctx.save(); ctx.translate(px + TILE_SIZE/2, py + TILE_SIZE/2); ctx.rotate(b.dir * Math.PI / 2);
                            ctx.fillRect(-12, -18, 24, 20); ctx.fillStyle = '#7f8c8d'; ctx.fillRect(-14, -20, 28, 6); ctx.restore();
                        }
                        else if (b.type === 'splitter') {
                            ctx.fillStyle = '#1abc9c'; ctx.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                            ctx.fillStyle = '#16a085'; ctx.fillRect(px + 10, py + 10, TILE_SIZE - 20, TILE_SIZE - 20);
                            ctx.fillStyle = '#fff'; ctx.save(); ctx.translate(px + TILE_SIZE/2, py + TILE_SIZE/2); ctx.rotate(b.dir * Math.PI / 2);
                            ctx.font = '12px Arial'; if(b.toggle) ctx.fillText('‚Üê', 0, -5); else ctx.fillText('‚Üí', 0, -5); ctx.restore();
                        }
                        else if (b.type === 'sorter') {
                            ctx.fillStyle = '#3498db'; ctx.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                            ctx.fillStyle = '#2980b9'; ctx.fillRect(px + 8, py + 8, TILE_SIZE - 16, TILE_SIZE - 16);
                            ctx.fillStyle = '#fff'; ctx.save(); ctx.translate(px + TILE_SIZE/2, py + TILE_SIZE/2); ctx.rotate(b.dir * Math.PI / 2);
                            ctx.font = '14px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('‚öô', 0, 0); ctx.restore();
                        }
                        else if (b.type === 'upgrader') {
                            ctx.fillStyle = '#e67e22'; ctx.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                            ctx.fillStyle = '#d35400'; let pulse = Math.abs(Math.sin(game.tick * 0.1)) * 4; ctx.fillRect(px + 10 - pulse/2, py + 10 - pulse/2, 20 + pulse, 20 + pulse);
                            ctx.fillStyle = '#fff'; ctx.save(); ctx.translate(px + TILE_SIZE/2, py + TILE_SIZE/2); ctx.rotate(b.dir * Math.PI / 2); ctx.fillText('‚Üë', 0, 0); ctx.restore();
                        }
                        else if (b.type === 'assembler') {
                            ctx.fillStyle = '#8e44ad'; ctx.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                            ctx.fillStyle = '#2c3e50'; ctx.fillRect(px + 8, py + 8, TILE_SIZE - 16, TILE_SIZE - 16);
                            if (b.inventory.proc_blue > 0) { ctx.fillStyle = '#2ecc71'; ctx.beginPath(); ctx.arc(px + TILE_SIZE/2 - 5, py + TILE_SIZE/2, 3, 0, Math.PI * 2); ctx.fill(); }
                            if (b.inventory.proc_orange > 0) { ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(px + TILE_SIZE/2 + 5, py + TILE_SIZE/2, 3, 0, Math.PI * 2); ctx.fill(); }
                            ctx.fillStyle = '#fff'; ctx.save(); ctx.translate(px + TILE_SIZE/2, py + TILE_SIZE/2); ctx.rotate(b.dir * Math.PI / 2); ctx.font = '10px Arial'; ctx.fillText('‚ñ≤', 0, -12); ctx.restore();
                        }
                        else if (b.type === 'integrator') {
                            ctx.fillStyle = '#ecf0f1'; ctx.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                            ctx.fillStyle = '#2c3e50'; ctx.beginPath(); ctx.arc(px+TILE_SIZE/2, py+TILE_SIZE/2, 12, 0, Math.PI*2); ctx.fill();
                            if (b.inventory.advanced_purple > 0) { ctx.fillStyle = '#9b59b6'; ctx.beginPath(); ctx.arc(px + TILE_SIZE/2 - 5, py + TILE_SIZE/2, 3, 0, Math.PI * 2); ctx.fill(); }
                            if (b.inventory.raw_pink > 0) { ctx.fillStyle = '#e84393'; ctx.beginPath(); ctx.arc(px + TILE_SIZE/2 + 5, py + TILE_SIZE/2, 3, 0, Math.PI * 2); ctx.fill(); }
                            ctx.fillStyle = '#000'; ctx.save(); ctx.translate(px + TILE_SIZE/2, py + TILE_SIZE/2); ctx.rotate(b.dir * Math.PI / 2); ctx.font = '10px Arial'; ctx.fillText('‚ñ≤', 0, -12); ctx.restore();
                        }
                        else if (b.type === 'compressor') {
                            ctx.fillStyle = '#000'; ctx.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                            ctx.fillStyle = '#2c3e50'; ctx.beginPath(); ctx.arc(px+TILE_SIZE/2, py+TILE_SIZE/2, 14, 0, Math.PI*2); ctx.fill();
                            ctx.fillStyle = '#fff'; ctx.save(); ctx.translate(px + TILE_SIZE/2, py + TILE_SIZE/2); ctx.rotate(game.tick * 0.05); ctx.fillRect(-8,-8,16,16); ctx.restore();
                            if(b.inventory.omega > 0) { ctx.fillStyle = '#fff'; ctx.font='10px Arial'; ctx.fillText(b.inventory.omega, px+10, py+10); }
                            ctx.fillStyle = '#e74c3c'; ctx.save(); ctx.translate(px + TILE_SIZE/2, py + TILE_SIZE/2); ctx.rotate(b.dir * Math.PI / 2); ctx.font = '10px Arial'; ctx.fillText('‚ñ≤', 0, -14); ctx.restore();
                        }
                        else if (b.type === 'miner') {
                            ctx.fillStyle = '#e74c3c'; ctx.beginPath(); ctx.moveTo(px + 8, py); ctx.lineTo(px + TILE_SIZE - 8, py); ctx.lineTo(px + TILE_SIZE, py + 8); ctx.lineTo(px + TILE_SIZE, py + TILE_SIZE - 8); ctx.lineTo(px + TILE_SIZE - 8, py + TILE_SIZE); ctx.lineTo(px + 8, py + TILE_SIZE); ctx.lineTo(px, py + TILE_SIZE - 8); ctx.lineTo(px, py + 8); ctx.fill();
                            ctx.fillStyle = '#c0392b'; ctx.beginPath(); ctx.arc(px + TILE_SIZE/2, py + TILE_SIZE/2, 8 + Math.sin(game.tick * 0.1) * 2, 0, Math.PI * 2); ctx.fill();
                        }
                        
                        if (game.power.efficiency < 1.0 && POWER_USAGE[b.type]) {
                            ctx.fillStyle = 'rgba(231, 76, 60, 0.8)';
                            if (game.tick % 60 < 30) { ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.fillText('‚ö°', px + TILE_SIZE - 10, py + 15); }
                        }
                    }
                }
            }

            for(let cx = startCX; cx < endCX; cx++) {
                for(let cy = startCY; cy < endCY; cy++) {
                    if(!game.unlockedChunks.has(`${cx},${cy}`)) {
                        let px = cx * CHUNK_SIZE * TILE_SIZE; let py = cy * CHUNK_SIZE * TILE_SIZE;
                        ctx.fillStyle = 'rgba(10, 10, 15, 0.9)'; ctx.fillRect(px, py, CHUNK_SIZE*TILE_SIZE, CHUNK_SIZE*TILE_SIZE);
                        
                        if (isChunkAdjacentToUnlocked(cx, cy)) {
                            ctx.fillStyle = 'rgba(52, 152, 219, 0.2)'; ctx.fillRect(px, py, CHUNK_SIZE*TILE_SIZE, CHUNK_SIZE*TILE_SIZE);
                            ctx.fillStyle = '#fff'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                            let cost = getChunkCost();
                            ctx.fillText(`üîí ${cost}¬¢`, px + (CHUNK_SIZE*TILE_SIZE)/2, py + (CHUNK_SIZE*TILE_SIZE)/2);
                            ctx.font = '12px Arial'; ctx.fillStyle = '#aaa'; ctx.fillText(`Cliquez pour d√©bloquer`, px + (CHUNK_SIZE*TILE_SIZE)/2, py + (CHUNK_SIZE*TILE_SIZE)/2 + 20);
                        }
                    }
                }
            }

            for (let e of game.enemies) {
                if (e.x >= startX - 1 && e.x <= endX && e.y >= startY - 1 && e.y <= endY) {
                    ctx.fillStyle = '#e74c3c';
                    let px = e.x * TILE_SIZE; let py = e.y * TILE_SIZE;
                    let glitch = (Math.random() - 0.5) * 4;
                    ctx.fillRect(px + 8 + glitch, py + 8 - glitch, TILE_SIZE - 16, TILE_SIZE - 16);
                    ctx.fillStyle = '#000'; ctx.fillRect(px + 12 + glitch, py + 12, 6, 6); ctx.fillRect(px + 22 + glitch, py + 12, 6, 6);
                }
            }

            ctx.lineWidth = 3;
            for (let l of game.lasers) {
                ctx.strokeStyle = `rgba(52, 152, 219, ${l.life / 10})`;
                ctx.beginPath(); ctx.moveTo(l.x1 * TILE_SIZE + TILE_SIZE/2, l.y1 * TILE_SIZE + TILE_SIZE/2); ctx.lineTo(l.x2 * TILE_SIZE + TILE_SIZE/2, l.y2 * TILE_SIZE + TILE_SIZE/2); ctx.stroke();
            }

            for (let item of game.items) {
                if (item.x >= startX - 1 && item.x <= endX && item.y >= startY - 1 && item.y <= endY) {
                    let colors = { 'raw_blue': '#00d2ff', 'proc_blue': '#2ecc71', 'raw_orange': '#ff9f43', 'proc_orange': '#feca57', 'advanced_purple': '#9b59b6', 'raw_pink': '#fd79a8', 'omega': '#ffffff', 'singularity': '#000000' };
                    ctx.fillStyle = colors[item.type]; ctx.shadowColor = item.type === 'singularity' ? '#fff' : colors[item.type]; 
                    ctx.shadowBlur = (item.type === 'omega' || item.type === 'singularity') ? 20 : 10;
                    if(item.type === 'singularity') { ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; }
                    let px = item.x * TILE_SIZE + TILE_SIZE / 2; let py = item.y * TILE_SIZE + TILE_SIZE / 2;
                    ctx.beginPath(); let radius = (item.type === 'omega' || item.type === 'singularity') ? 8 : (item.type === 'advanced_purple' ? 6 : 4);
                    ctx.arc(px, py, radius, 0, Math.PI * 2); ctx.fill();
                    if(item.type === 'singularity') ctx.stroke();
                }
            }
            ctx.shadowBlur = 0;

            ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = 'bold 16px Arial';
            for (let p of game.particles) {
                if (p.x/TILE_SIZE >= startX && p.x/TILE_SIZE <= endX && p.y/TILE_SIZE >= startY && p.y/TILE_SIZE <= endY) {
                    ctx.fillStyle = p.color; ctx.globalAlpha = Math.max(0, p.life / p.maxLife); ctx.fillText(p.text, p.x, p.y);
                }
            }
            ctx.globalAlpha = 1.0;

            // Info-bulle pour les gisements au survol
            let gx = Math.floor(game.worldX / TILE_SIZE); let gy = Math.floor(game.worldY / TILE_SIZE);
            if (gx >= 0 && gx < game.gridWidth && gy >= 0 && gy < game.gridHeight && !game.isMiddleDragging) {
                let hoverTile = game.grid[gx][gy];
                if (hoverTile && hoverTile.resource && isChunkUnlocked(gx, gy)) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.fillRect(gx * TILE_SIZE, (gy - 1) * TILE_SIZE + 15, TILE_SIZE * 2.5, 20);
                    ctx.fillStyle = '#fff'; ctx.font = '12px Arial'; ctx.textAlign = 'left';
                    ctx.fillText(`${hoverTile.resource.amount} / ${hoverTile.resource.max}`, gx * TILE_SIZE + 5, (gy - 1) * TILE_SIZE + 25);
                }
            }

            if (gx >= 0 && gx < game.gridWidth && gy >= 0 && gy < game.gridHeight && !game.isMiddleDragging) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)'; ctx.lineWidth = 2 / game.zoom; ctx.strokeRect(gx * TILE_SIZE, gy * TILE_SIZE, TILE_SIZE, TILE_SIZE);

                if (['belt', 'miner', 'upgrader', 'splitter', 'sorter', 'assembler', 'integrator', 'compressor', 'tunnel', 'trash', 'generator', 'firewall', 'hub'].includes(game.buildMode)) {
                    ctx.globalAlpha = 0.5; let px = gx * TILE_SIZE; let py = gy * TILE_SIZE;
                    ctx.save(); ctx.translate(px + TILE_SIZE/2, py + TILE_SIZE/2); ctx.rotate(game.currentDir * Math.PI / 2);
                    
                    if (game.buildMode === 'belt') { ctx.fillStyle = '#34495e'; ctx.fillRect(-18, -18, 36, 36); ctx.fillStyle='#fff'; ctx.fillText('‚Üë', 0, 0); }
                    else if (game.buildMode === 'tunnel') { ctx.fillStyle = '#2c3e50'; ctx.fillRect(-18, -18, 36, 36); ctx.fillStyle='#111'; ctx.fillRect(-12,-18,24,20); }
                    else if (game.buildMode === 'trash') { ctx.fillStyle = '#c0392b'; ctx.fillRect(-16, -16, 32, 32); }
                    else if (game.buildMode === 'upgrader') { ctx.fillStyle = '#e67e22'; ctx.fillRect(-18, -18, 36, 36); ctx.fillStyle='#fff'; ctx.fillText('‚Üë', 0, 0); }
                    else if (game.buildMode === 'splitter') { ctx.fillStyle = '#1abc9c'; ctx.fillRect(-18, -18, 36, 36); ctx.fillStyle='#fff'; ctx.fillText('Y', 0, 0); }
                    else if (game.buildMode === 'sorter') { ctx.fillStyle = '#3498db'; ctx.fillRect(-18, -18, 36, 36); ctx.fillStyle='#fff'; ctx.fillText('‚öô', 0, 0); }
                    else if (game.buildMode === 'assembler') { ctx.fillStyle = '#8e44ad'; ctx.fillRect(-18, -18, 36, 36); }
                    else if (game.buildMode === 'integrator') { ctx.fillStyle = '#ecf0f1'; ctx.fillRect(-18, -18, 36, 36); }
                    else if (game.buildMode === 'compressor') { ctx.fillStyle = '#000'; ctx.fillRect(-18, -18, 36, 36); }
                    else if (game.buildMode === 'miner') { ctx.fillStyle = '#e74c3c'; ctx.fillRect(-16, -16, 32, 32); }
                    else if (game.buildMode === 'generator') { ctx.fillStyle = '#f1c40f'; ctx.fillRect(-18, -18, 36, 36); ctx.fillStyle='#000'; ctx.font='20px Arial'; ctx.fillText('‚ö°', 0, 0); }
                    else if (game.buildMode === 'hub') { ctx.fillStyle = '#3498db'; ctx.fillRect(-18, -18, 36, 36); ctx.fillStyle='#fff'; ctx.font='12px Arial'; ctx.fillText('HUB', 0, 0); }
                    else if (game.buildMode === 'firewall') { 
                        ctx.fillStyle = '#c0392b'; ctx.fillRect(-18, -18, 36, 36); ctx.fillStyle='#fff'; ctx.font='20px Arial'; ctx.fillText('‚ôú', 0, 0); 
                        ctx.strokeStyle = 'rgba(231, 76, 60, 0.2)'; ctx.beginPath(); ctx.arc(0, 0, TILE_SIZE * 5, 0, Math.PI*2); ctx.stroke(); ctx.fillStyle = 'rgba(231, 76, 60, 0.05)'; ctx.fill();
                    }
                    
                    ctx.restore(); ctx.globalAlpha = 1.0;
                }
            }
            ctx.restore();

            let mapSize = 150; let mapX = canvas.width - mapSize - 20; let mapY = canvas.height - mapSize - 20;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(mapX, mapY, mapSize, mapSize); ctx.strokeStyle = '#4db8ff'; ctx.lineWidth = 2; ctx.strokeRect(mapX, mapY, mapSize, mapSize);
            let scaleX = mapSize / game.gridWidth; let scaleY = mapSize / game.gridHeight;
            for (let x = 0; x < game.gridWidth; x++) {
                for (let y = 0; y < game.gridHeight; y++) {
                    let cx = Math.floor(x / CHUNK_SIZE); let cy = Math.floor(y / CHUNK_SIZE);
                    if(!game.unlockedChunks.has(`${cx},${cy}`)) continue;

                    let t = game.grid[x][y];
                    if (t.building) {
                        if (t.building.type === 'core' || t.building.type === 'hub') ctx.fillStyle = '#f1c40f';
                        else if (t.building.type === 'firewall' || t.building.type === 'generator') ctx.fillStyle = '#e74c3c';
                        else ctx.fillStyle = '#7f8c8d';
                        ctx.fillRect(mapX + x * scaleX, mapY + y * scaleY, scaleX, scaleY);
                    } else if (t.resource) {
                        if (t.resource.type === 'node_blue') ctx.fillStyle = '#2980b9';
                        if (t.resource.type === 'node_orange') ctx.fillStyle = '#d35400';
                        if (t.resource.type === 'node_pink') ctx.fillStyle = '#8e44ad';
                        ctx.fillRect(mapX + x * scaleX, mapY + y * scaleY, scaleX, scaleY);
                    }
                }
            }
            for (let e of game.enemies) { ctx.fillStyle = '#ff0000'; ctx.fillRect(mapX + e.x * scaleX, mapY + e.y * scaleY, scaleX * 2, scaleY * 2); }

            ctx.save(); ctx.beginPath(); ctx.rect(mapX, mapY, mapSize, mapSize); ctx.clip(); 
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; ctx.lineWidth = 1;
            let vw = (canvas.width / (TILE_SIZE * game.zoom)) * scaleX; let vh = (canvas.height / (TILE_SIZE * game.zoom)) * scaleY;
            let vx = mapX + (-game.camera.x / (TILE_SIZE * game.zoom)) * scaleX; let vy = mapY + (-game.camera.y / (TILE_SIZE * game.zoom)) * scaleY;
            ctx.strokeRect(vx, vy, vw, vh); ctx.restore();
        }

        function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }

        // --- INTERACTIONS UI ---
        function updateUI() {
            document.getElementById('moneyDisplay').innerText = game.money + ' ¬¢';
            document.getElementById('dirDisplay').innerText = DIRS[game.currentDir].name + ' (' + DIRS[game.currentDir].symbol + ')';
            
            let pDisplay = document.getElementById('powerDisplay');
            pDisplay.innerText = `${game.power.produced} / ${game.power.consumed} W`;
            pDisplay.className = `stat-value ${game.power.efficiency < 1.0 ? 'power-low' : 'power-ok'}`;

            let gx = Math.floor(game.worldX / TILE_SIZE); let gy = Math.floor(game.worldY / TILE_SIZE);
            document.getElementById('coordsDisplay').innerText = `X:${gx}, Y:${gy} | Zoom: ${Math.round(game.zoom*100)}%`;

            let cm = game.missions[game.missionIndex];
            document.getElementById('missionTitle').innerText = cm.title;
            document.getElementById('missionDesc').innerHTML = cm.desc.replace(/\n/g, '<br>');
            
            if (cm.req > 0) {
                let pct = Math.min((game.missionProgress / cm.req) * 100, 100);
                document.getElementById('missionBar').style.width = pct + '%';
                document.getElementById('missionText').innerText = game.missionProgress + ' / ' + cm.req;
            } else { document.getElementById('missionBar').style.width = '100%'; document.getElementById('missionText').innerText = "‚àû"; }

            document.getElementById('btn-tunnel').style.display = isUnlocked('tunnel') ? 'flex' : 'none';
            document.getElementById('btn-splitter').style.display = isUnlocked('splitter') ? 'flex' : 'none';
            document.getElementById('btn-sorter').style.display = isUnlocked('sorter') ? 'flex' : 'none';
            document.getElementById('btn-upgrader').style.display = isUnlocked('upgrader') ? 'flex' : 'none';
            document.getElementById('btn-assembler').style.display = isUnlocked('assembler') ? 'flex' : 'none';
            document.getElementById('btn-integrator').style.display = isUnlocked('integrator') ? 'flex' : 'none';
            document.getElementById('btn-compressor').style.display = isUnlocked('compressor') ? 'flex' : 'none';
            document.getElementById('btn-trash').style.display = isUnlocked('trash') ? 'flex' : 'none';
            document.getElementById('btn-hub').style.display = isUnlocked('hub') ? 'flex' : 'none';
            
            let showSec = isUnlocked('generator');
            document.getElementById('btn-generator').style.display = showSec ? 'flex' : 'none';
            document.getElementById('btn-firewall').style.display = showSec ? 'flex' : 'none';
            document.getElementById('hr-security').style.display = showSec ? 'block' : 'none';
        }

        function setBuildMode(mode) {
            if (!isUnlocked(mode)) return;
            game.buildMode = mode;
            document.querySelectorAll('.btn').forEach(btn => btn.classList.remove('active'));
            let b = document.getElementById(`btn-${mode}`);
            if(b) b.classList.add('active');
            else if(mode === 'cursor') document.querySelectorAll('.btn')[0].classList.add('active');
            else if(mode === 'pan') document.querySelectorAll('.btn')[1].classList.add('active');
            else if(mode === 'delete') document.querySelectorAll('.btn')[document.querySelectorAll('.btn').length - 1].classList.add('active');
        }

        window.addEventListener('keydown', (e) => {
            game.keys[e.key.toLowerCase()] = true; game.keys[e.key] = true; 
            if (e.key.toLowerCase() === 'r') { game.currentDir = (game.currentDir + 1) % 4; updateUI(); }
            if (e.key === 'Escape') {
                let upgMod = document.getElementById('upgrade-modal'); let sortMod = document.getElementById('sorter-modal');
                if (upgMod.style.display === 'block') { upgMod.style.display = 'none'; }
                else if (sortMod.style.display === 'block') { sortMod.style.display = 'none'; }
                else {
                    let bs = document.getElementById('boss-screen');
                    if(bs.style.display !== 'block') {
                        document.getElementById('fake-time').innerText = new Date().toLocaleDateString() + ' ' + new Date().toLocaleTimeString();
                        bs.style.display = 'block';
                    } else bs.style.display = 'none';
                }
            }
            if(e.key === '1') setBuildMode('cursor');
            if(e.key.toLowerCase() === 'm') setBuildMode('pan');
            if(e.key === '2') setBuildMode('miner');
            if(e.key === '3') setBuildMode('belt');
            if(e.key === '4') setBuildMode('tunnel');
            if(e.key === '5') setBuildMode('splitter');
            if(e.key === '6') setBuildMode('sorter');
            if(e.key === '7') setBuildMode('upgrader');
            if(e.key === '8') setBuildMode('assembler');
            if(e.key === '9') setBuildMode('integrator');
            if(e.key.toLowerCase() === 'c') setBuildMode('compressor');
            if(e.key === '0') setBuildMode('trash');
            if(e.key.toLowerCase() === 'g') setBuildMode('generator');
            if(e.key.toLowerCase() === 'f') setBuildMode('firewall');
            if(e.key.toLowerCase() === 'h') setBuildMode('hub');
            if(e.key.toLowerCase() === 'x') setBuildMode('delete');
        });
        
        window.addEventListener('keyup', (e) => { game.keys[e.key.toLowerCase()] = false; game.keys[e.key] = false; });

        window.addEventListener('mousemove', (e) => {
            if (game.paintButton === 1 || (game.paintButton === 0 && game.buildMode === 'pan')) {
                game.camera.x += e.clientX - game.lastMouse.x; game.camera.y += e.clientY - game.lastMouse.y;
            }
            game.lastMouse.x = e.clientX; game.lastMouse.y = e.clientY;
            game.mouseX = e.clientX; game.mouseY = e.clientY;
            game.worldX = (e.clientX - game.camera.x) / game.zoom; game.worldY = (e.clientY - game.camera.y) / game.zoom;
            
            if (game.paintButton !== null && game.paintButton !== 1 && game.buildMode !== 'pan' && game.buildMode !== 'cursor') {
                let gx = Math.floor(game.worldX / TILE_SIZE); let gy = Math.floor(game.worldY / TILE_SIZE);
                tryBuild(gx, gy, game.paintButton === 2);
            }
            updateUI();
        });

        canvas.addEventListener('mousedown', (e) => {
            if (e.target.closest('.modal')) return;
            game.lastMouse.x = e.clientX; game.lastMouse.y = e.clientY; game.paintButton = e.button; 
            if (e.button === 1) e.preventDefault(); 
            
            let gx = Math.floor(game.worldX / TILE_SIZE); let gy = Math.floor(game.worldY / TILE_SIZE);
            let cx = Math.floor(gx / CHUNK_SIZE); let cy = Math.floor(gy / CHUNK_SIZE);
            
            // Achat de secteur
            if (!game.unlockedChunks.has(`${cx},${cy}`)) {
                if (isChunkAdjacentToUnlocked(cx, cy) && e.button === 0 && game.buildMode === 'cursor') {
                    let cost = getChunkCost();
                    if (game.money >= cost) {
                        game.money -= cost;
                        game.unlockedChunks.add(`${cx},${cy}`);
                        game.particles.push(new Particle(gx*TILE_SIZE, gy*TILE_SIZE, "SECTEUR ACHET√â", "#2ecc71"));
                        updateUI(); saveGame();
                    } else {
                        game.particles.push(new Particle(gx*TILE_SIZE, gy*TILE_SIZE, "FONDS INSUFFISANTS", "#e74c3c"));
                    }
                }
                return; 
            }

            if (game.buildMode === 'cursor' && e.button === 0) {
                if (gx >= 0 && gx < game.gridWidth && gy >= 0 && gy < game.gridHeight) {
                    let tile = game.grid[gx][gy];
                    if (tile && tile.building && tile.building.type === 'sorter') { openSorterConfig(gx, gy); return; }
                }
            }
            if (game.buildMode !== 'pan' && e.button !== 1) tryBuild(gx, gy, e.button === 2);
        });

        canvas.addEventListener('wheel', (e) => {
            if (document.getElementById('boss-screen').style.display === 'block') return;
            if (document.getElementById('upgrade-modal').style.display === 'block') return;
            if (document.getElementById('sorter-modal').style.display === 'block') return;
            e.preventDefault(); 
            let wx = (e.clientX - game.camera.x) / game.zoom; let wy = (e.clientY - game.camera.y) / game.zoom;
            let zoomSpeed = 0.1;
            if (e.deltaY < 0) game.zoom = Math.min(2.5, game.zoom + zoomSpeed); else game.zoom = Math.max(0.4, game.zoom - zoomSpeed);
            game.camera.x = e.clientX - wx * game.zoom; game.camera.y = e.clientY - wy * game.zoom;
            game.worldX = (e.clientX - game.camera.x) / game.zoom; game.worldY = (e.clientY - game.camera.y) / game.zoom;
            updateUI();
        }, {passive: false});

        window.addEventListener('mouseup', () => { game.paintButton = null; });
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        function generateFakeData() {
            let tbody = document.getElementById('fake-table-body'); let html = '';
            for(let i=0; i<18; i++) {
                let id = Math.floor(Math.random() * 9000 + 1000);
                let op = ['nginx', 'mysql', 'redis', 'node_worker', 'php-fpm'][Math.floor(Math.random()*5)];
                let statuts = ['<span style="color:green;">RUNNING</span>', '<span style="color:green;">RUNNING</span>', '<span style="color:orange;">SLEEP</span>', '<span style="color:red;">ZOMBIE</span>'];
                let statut = statuts[Math.floor(Math.random()*statuts.length)];
                let mem = (Math.random() * 500 + 50).toFixed(1);
                let time = Math.floor(Math.random() * 200) + 'h ' + Math.floor(Math.random() * 60) + 'm';
                html += `<tr><td>${id}</td><td>${op}</td><td>${statut}</td><td>${mem}</td><td>${time}</td></tr>`;
            }
            tbody.innerHTML = html;
        }

        window.addEventListener('resize', resize);
        generateFakeData(); resize(); 
        if (!loadGame()) initGrid();
        calculatePower(); updateUI(); gameLoop();
    </script>
</body>
</html>
